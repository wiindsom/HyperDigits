{"searchDocs":[{"title":"Getting Started","type":0,"sectionRef":"#","url":"/HyperDigits/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Pre-Requisite‚Äã","type":1,"pageTitle":"Getting Started","url":"/HyperDigits/docs/intro#pre-requisite","content":" Structix started as a simple side project something I didn‚Äôt expect to go far with. If you're unfamiliar with any of the data structures showcased here, or if you're not sure how they work or what they‚Äôre for, I recommend taking a moment to research them online. A solid understanding of their general behavior and use cases will help you get the most out of this library. If you're still with me, great. I‚Äôll do my best to explain each structure and how it functions within Structix ‚Üí Dive Into The Concepts   ","version":"Next","tagName":"h2"},{"title":"Pros","type":0,"sectionRef":"#","url":"/HyperDigits/docs/ProsAndCons/pros","content":"Pros üîíStrict Typing &amp; API Safety Structix somewhat enforces strict types, reducing runtime errors and catches mistakes early making it great for any scale projects.üìñReadable, Maintainable Code We love readable code!‚öôÔ∏èCustomizable Behavior Support for modes, comparators, and features like min/max in (Heap, Priority Queue) which lets you tailor performance and logic to your needs.üìãUnified Interface Consistent methods like size, clear, copy across all structures reduce the learning curve and makes it easy to compare structure sizes/copies.üåÄSafe Cloning &amp; Equality API Built in copy/equality methods making it safe and easy to copy/compare the structures.","keywords":"","version":"Next"},{"title":"Cons","type":0,"sectionRef":"#","url":"/HyperDigits/docs/ProsAndCons/cons","content":"Cons üê¢Slight Overhead Wrapper functions add some performance and memory cost compared to raw tables, though negligible in most cases.üìòLearning Curve Beginners unfamiliar with data structures like trees or dequeues might need some time to understand and when to use them.üö´Unnecessary Structures Most of these data structures you'll find unnecessary in development because it needs to have a very specific usecase. Roblox games typically only need structures like arrays, dictionaries to function.üîÑManual Replication Structix data is local to memory, meaning you'll need to handle syncing between client/server manually if needed.ü™∂Not Always Relevant For very small, temporary, or throwaway data sets, plain roblox tables might be simpler and faster to use.","keywords":"","version":"Next"},{"title":"Concepts","type":0,"sectionRef":"#","url":"/HyperDigits/docs/concepts","content":"","keywords":"","version":"Next"},{"title":"Binary Tree‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#binary-tree","content":" A Binary Tree branches like a decision tree. Each node has two children: left and right. When ordered, it becomes a Binary Search Tree, which makes lookups fast. Trees model hierarchies, expressions, file systems, and even spatial zones in games. Learn More About Binary Trees    ","version":"Next","tagName":"h2"},{"title":"Collection‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#collection","content":" A Collection is a flexible, ordered group of items like a dynamic array. It gives you tools to manipulate, iterate, and transform values in bulk. Think of it as a friendly workspace for general-purpose list processing, filtering, and reshaping data. Learn More About Collections    ","version":"Next","tagName":"h2"},{"title":"Deque‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#deque","content":" A Deque (also known as a Double Ended Queue) gives you control at both ends. You can add or remove items from the front or back. It‚Äôs flexible and ideal when you need both stack and queue behaviors think of it as a two-way street for data flow. Learn More About Deques    ","version":"Next","tagName":"h2"},{"title":"Heap‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#heap","content":" A Heap keeps the most important item (according to your rules) at the top. In a min-heap, the smallest item rises. In a max-heap, the largest does. Heaps power efficient priority management like job schedulers and pathfinding. Learn More About Heaps    ","version":"Next","tagName":"h2"},{"title":"Linked List‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#linked-list","content":" A LinkedList connects data like a chain. Each piece points to the next (and sometimes the previous). It‚Äôs not fast for random access but excels at efficient insertions and deletions especially in the middle. Use it when flexibility beats speed. Learn More About Linked Lists    ","version":"Next","tagName":"h2"},{"title":"Map‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#map","content":" A Map (or dictionary) links keys to values. You use a key to retrieve its paired value. It‚Äôs ideal for storing associations like a username mapped to a score, or an item ID mapped to its description. Maps are essential for fast lookups. Learn More About Maps    ","version":"Next","tagName":"h2"},{"title":"Priority Queue‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#priority-queue","content":" A PriorityQueue is like a line where some people are allowed to cut in front based on urgency. Each element has a priority. The queue always serves the most critical item first. It's a higher-level abstraction built on a heap, perfect for game events, task queues, or AI decision systems. Learn More About Priority Queues    ","version":"Next","tagName":"h2"},{"title":"Queue‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#queue","content":" A Queue is a line of people waiting their turn. It follows First-In, First-Out (FIFO). The first element in is the first to be removed. Queues are perfect for scheduling, turn-based logic, and managing sequences where order matters. Learn More About Queues    ","version":"Next","tagName":"h2"},{"title":"Set‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#set","content":" A Set is a collection of unique items. No duplicates allowed. It‚Äôs great for checking membership, enforcing uniqueness, and doing operations like unions, intersections, and differences just like in mathematics. Learn More About Sets    ","version":"Next","tagName":"h2"},{"title":"Stack‚Äã","type":1,"pageTitle":"Concepts","url":"/HyperDigits/docs/concepts#stack","content":" A Stack is like a stack of plates: the last one you put on is the first one you take off. It follows the Last-In, First-Out (LIFO) principle. Use it when you need to undo actions, backtrack, or manage nested operations like call stacks in programming or game state rewinds. Learn More About Stacks   ","version":"Next","tagName":"h2"},{"title":"Basic Setup","type":0,"sectionRef":"#","url":"/HyperDigits/docs/Usage/binarytree","content":"Basic Setup local Structix = require(&quot;/path/to/Structix&quot;) local BinaryTree = Structix.BinaryTree local tree = BinaryTree.new() ","keywords":"","version":"Next"}],"options":{"id":"default"}}